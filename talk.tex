\documentclass{beamer}

\usepackage{minted}

\newminted{rust}{bgcolor=bg}
\newminted{c}{bgcolor=bg}

\AtBeginSection[]{
    \begin{frame}
        \begin{center}
            \usebeamerfont{title}\secname
        \end{center}
    \end{frame}
}

\AtBeginSubsection[]{
    \begin{frame}
        \begin{center}
            \usebeamerfont{subtitle}\subsecname
        \end{center}
    \end{frame}
}

\setlength{\parskip}{2ex}

\title{FFI in Rust}
\subtitle{Lessons from OpenSSL}
\author[sfackler]{Steven Fackler - sfackler}
\date{December 15, 2016}

\begin{document}
\definecolor{bg}{rgb}{.95,.95,.95}

\frame{\titlepage}

\frame{\tableofcontents}

\section{Basics}

\begin{frame}{What is FFI?}
    \begin{quote}
        ``A foreign function interface (FFI) is a mechanism by which a program
        written in one programming language can call routines or make use of
        services written in another.''
    \end{quote}
\end{frame}

\begin{frame}{Why FFI?}
    Lots of code has been written in languages that aren't Rust!

    \begin{itemize}
        \item Use Rust to accelerate portions of programs written in higher
            level languages. (jni, neon, ruru)
        \item Expose a C interface for your Rust library. (regex)
        \item Interact with libraries exposing C APIs. (openssl, curl,
            rusqlite)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example}
    \begin{ccode}
struct foo {
    long a;
    char *b;
};
int fizzbuzz(const struct foo *f);
    \end{ccode}
    \vspace{10pt}
    \begin{rustcode}
#[repr(C)]
struct foo {
    a: c_long,
    b: *mut c_char,
}
extern {
    fn fizzbuzz(f: *const foo) -> c_int;
}
    \end{rustcode}
\end{frame}

\section{-sys Crates}

\begin{frame}{-sys?}
    A `-sys' crate provides a direct transcription of a C API into Rust - think
    of them as Rust's version of header files.

    Also responsible for linking to the C library.
\end{frame}

\begin{frame}[fragile]{Bindgen}
    Bindgen uses libclang to parse C headers and produce Rust definitions from
    them.

    \begin{verbatim}
$ bindgen fizzbuzz.h
/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct foo {
    pub a: ::std::os::raw::c_long,
...
    \end{verbatim}
\end{frame}

\begin{frame}{Caveats}
    While Bindgen is fantastic to quickly get Rust bindings for a header, it
    has some drawbacks:

    \begin{itemize}
        \item libclang is a fairly heavyweight dependency.
        \item It produces definitions valid in the environment it's run.
        \item It can be a bit verbose, particularly when system headers are
            included.
    \end{itemize}

    rust-openssl does not use bindgen for its bindings.
\end{frame}

\begin{frame}{The Manual Approach}
\end{frame}

\end{document}
