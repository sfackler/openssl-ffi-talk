\documentclass{beamer}

\usepackage{minted}

\newminted{rust}{bgcolor=bg}
\newminted{c}{bgcolor=bg}

\AtBeginSection[]{
    \begin{frame}
        \begin{center}
            \usebeamerfont{title}\secname
        \end{center}
    \end{frame}
}

\AtBeginSubsection[]{
    \begin{frame}
        \begin{center}
            \usebeamerfont{subtitle}\subsecname
        \end{center}
    \end{frame}
}

\setlength{\parskip}{2ex}

\title{FFI in Rust}
\subtitle{Lessons from OpenSSL}
\author[sfackler]{Steven Fackler - sfackler}
\date{December 15, 2016}

\begin{document}
\definecolor{bg}{rgb}{.95,.95,.95}

\frame{\titlepage}

\frame{\tableofcontents}

\section{Basics}

\begin{frame}{What is FFI?}
    \begin{quote}
        ``A foreign function interface (FFI) is a mechanism by which a program
        written in one programming language can call routines or make use of
        services written in another.''
    \end{quote}
\end{frame}

\begin{frame}{Why FFI?}
    Lots of code has been written in languages that aren't Rust!

    \begin{itemize}
        \item Use Rust to accelerate portions of programs written in higher
            level languages. (jni, neon, ruru)
        \item Expose a C interface for your Rust library. (regex)
        \item Interact with libraries exposing C APIs. (openssl, curl,
            rusqlite)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example}
    \begin{ccode}
struct foo {
    long a;
    char *b;
};
int fizzbuzz(const struct foo *f);
    \end{ccode}
    \vspace{10pt}
    \begin{rustcode}
#[repr(C)]
struct foo {
    a: c_long,
    b: *mut c_char,
}
extern {
    fn fizzbuzz(f: *const foo) -> c_int;
}
    \end{rustcode}
\end{frame}

\section{openssl-sys}

\begin{frame}{-sys?}
    A `-sys' crate provides a direct transcription of a C API into Rust - think
    of them as Rust's version of header files.

    Also responsible for linking to the C library.
\end{frame}

\begin{frame}[fragile]{Bindgen}
    Bindgen uses libclang to parse C headers and produce Rust definitions from
    them.

    \begin{verbatim}
$ bindgen fizzbuzz.h
/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct foo {
    pub a: ::std::os::raw::c_long,
...
    \end{verbatim}
\end{frame}

\begin{frame}{Caveats}
    While Bindgen is fantastic to quickly get Rust bindings for a header, it
    has some drawbacks:

    \begin{itemize}
        \item libclang is a fairly heavyweight dependency.
        \item It can be a bit verbose, particularly when system headers are
            included.
        \item It produces definitions valid in the environment it's run.
    \end{itemize}

    rust-openssl does not use bindgen for its bindings.
\end{frame}

\begin{frame}[fragile]{The Manual Approach}
    You will get things wrong if you try to do it by hand. \pause

    \begin{rustcode}
extern {
    pub fn SSL_CTX_use_certificate_file(
        ctx: *mut SSL_CTX,
        cert_file: *const c_char,
        file_type: c_int)
        -> c_int;

    pub fn SSL_CTX_use_certificate_chain_file(
        ctx: *mut SSL_CTX,
        cert_chain_file: *const c_char,
        file_type: c_int) // OOPS
        -> c_int;
}
    \end{rustcode}
\end{frame}

\begin{frame}[fragile]{ctest}
    The `ctest' crate will check that your bindings correctly correspond to the
    C definitions.

    \begin{verbatim}
error: incompatible pointer types returning 'int
    (SSL_CTX *, const char *)' (aka 'int (struct
    ssl_ctx_st *, const char *)') from a function
    with result type 'int (*)(SSL_CTX *, const
    char *, int)' (aka 'int (*)(struct ssl_ctx_st *,
    const char *, int)')
    [-Werror,-Wincompatible-pointer-types]

    return SSL_CTX_use_certificate_chain_file;
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    \end{verbatim}
\end{frame}

\begin{frame}[fragile]{Version/Feature Detection}
    OpenSSL releases are not binary compatible, but 1.0.1, 1.0.2, and 1.1.0 are
    all supported by rust-openssl. Features have been added and removed;
    structs have been made opaque.

    OpenSSL's feature set can be customized at compile time. Constants,
    functions, and even struct fields are removed!

    \begin{ccode}
struct ssl_ctx_st {
    // ...
    int references;
    // ...
#  ifndef OPENSSL_NO_TLSEXT
    unsigned alpn_client_proto_list_len;
    // ...
#  endif
    // ...
};
    \end{ccode}
\end{frame}

\begin{frame}[fragile]{Version/Feature Detection}
    The \verb!opensslv.h! header contains \verb!#define!s for the version and
    all compile time feature flags. Parse it in a build script and turn those
    into Rust cfgs!

    \begin{rustcode}
#[repr(C)]
pub struct SSL_CTX {
    // ...
    pub references: c_int,
    // ...
    #[cfg(all(not(osslconf = "OPENSSL_NO_TLSEXT"),
              ossl102))]
    alpn_client_proto_list_len: c_uint,
    // ...
}
    \end{rustcode}
\end{frame}

\section{openssl}

\subsection{Ownership}

\begin{frame}{Figuring it Out}
    Ownership semantics are as important to C libraries as they are in Rust,
    but handled implicitly.

    If you're lucky, your library defines ownership conventions:
    \begin{itemize}
        \item OpenSSL - get1/get0, set1/set0, add1/add0
        \item Core Foundation - The Create Rule
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Figuring it Out}
    These are probably not enough.

    The majority of OpenSSL's APIs do not use the get1/get0 convention!

    Some functions are special snowflakes - \verb!X509_STORE_add_cert! takes
    ownership of its argument even when an error is encountered. \pause

    \begin{center}
        \LARGE The Source is the Only Source of Truth.
    \end{center}
\end{frame}

\begin{frame}[fragile]{Translating}
    openssl takes a dual-type approach - think \verb!Path!/\verb!PathBuf!:

    \begin{rustcode}
pub struct X509Ref(UnsafeCell<()>);

pub struct X509(*mut ffi::X509);

impl Drop for X509 { /* ... */ }

impl Deref for X509 {
    type Target = X509Ref;
    // ...
}

impl DerefMut for X509 { /* ... */ }
    \end{rustcode}
\end{frame}

\begin{frame}[fragile]{Fun With Pointers}
    \begin{rustcode}
impl X509Ref {
    pub unsafe fn from_ptr<'a>(ptr: *mut ffi::X509)
                               -> &'a X509Ref {
        &*(ptr as *mut _)
    }

    pub fn as_ptr(&self) -> *mut ffi::X509 {
        self as *const _ as *mut _
    }
}

impl Deref for X509 {
    fn deref(&self) -> &X509Ref {
        unsafe { X509Ref::from_ptr(self.0) }
    }
}
    \end{rustcode}
\end{frame}

\begin{frame}{Enums}
    Rust enums are not like C enums!
\end{frame}

\begin{frame}{Callbacks}
    Never forget about panics! Unwinding through non-Rust is undefined
    behavior.
\end{frame}

\begin{frame}{Version/Feature Detection}
    Recall:
    \begin{itemize}
        \item Three versions of OpenSSL supported. Each adds and removes
            functionality.
        \item Features can be disabled at OpenSSL build time.
    \end{itemize}

    Approach:
    \begin{itemize}
        \item Cargo features for each OpenSSL version. Each enables
            functionality exposed in that version \emph{when linking against
            it}. Crates can ask openssl-sys which version has been detected in
            a build script.
        \item Features that are disabled by OpenSSL build flags are simply
            removed when those flags are set.
    \end{itemize}
\end{frame}

\begin{frame}{Stay True to the Library}

\end{frame}

\begin{frame}[fragile]{... But Not Always}
    OpenSSL's default TLS configuration is a \textbf{nightmare}.

    On the client side, certificate validation is disabled entirely by default
    (!!). Even if you turn that on, hostname validation is either not supported
    at all or must be enabled and configured separately.

    On the server side, ephemeral key exchange is disabled by default. The
    steps to enable ECDHE are different in \emph{each} of the OpenSSL versions
    we support!

    On both sides, SSLv2 and SSLv3 will be enabled by default (maybe), and the
    default cipher suite list is larger than recommended.
\end{frame}

\begin{frame}[fragile]{... But Not Always}
    \begin{center}
        \Large If you are using an \verb!SslContext! directly, you are probably
        doing it wrong.
    \end{center}

    \pause

    Clients - \verb!SslConnector! provides a configuration modeled after Python
    3.6's.

    Servers - \verb!SslAcceptor! provides configurations modeled after the
    modern and intermediate profiles of Mozilla's Server Side TLS
    recommendations.
\end{frame}

\section{Wrapup}

\begin{frame}{Questions?}
\end{frame}

\end{document}
